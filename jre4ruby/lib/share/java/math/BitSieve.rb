require "rjava"

# Copyright 1999-2007 Sun Microsystems, Inc.  All Rights Reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
# 
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Sun designates this
# particular file as subject to the "Classpath" exception as provided
# by Sun in the LICENSE file that accompanied this code.
# 
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
# 
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
# 
# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
# CA 95054 USA or visit www.sun.com if you need additional information or
# have any questions.
module Java::Math
  module BitSieveImports #:nodoc:
    class_module.module_eval {
      include ::Java::Lang
      include ::Java::Math
    }
  end
  
  # A simple bit sieve used for finding prime number candidates. Allows setting
  # and clearing of bits in a storage array. The size of the sieve is assumed to
  # be constant to reduce overhead. All the bits of a new bitSieve are zero, and
  # bits are removed from it by setting them.
  # 
  # To reduce storage space and increase efficiency, no even numbers are
  # represented in the sieve (each bit in the sieve represents an odd number).
  # The relationship between the index of a bit and the number it represents is
  # given by
  # N = offset + (2*index + 1);
  # Where N is the integer represented by a bit in the sieve, offset is some
  # even integer offset indicating where the sieve begins, and index is the
  # index of a bit in the sieve array.
  # 
  # @see     BigInteger
  # @author  Michael McCloskey
  # @since   1.3
  class BitSieve 
    include_class_members BitSieveImports
    
    # Stores the bits in this bitSieve.
    attr_accessor :bits
    alias_method :attr_bits, :bits
    undef_method :bits
    alias_method :attr_bits=, :bits=
    undef_method :bits=
    
    # Length is how many bits this sieve holds.
    attr_accessor :length
    alias_method :attr_length, :length
    undef_method :length
    alias_method :attr_length=, :length=
    undef_method :length=
    
    class_module.module_eval {
      # A small sieve used to filter out multiples of small primes in a search
      # sieve.
      
      def small_sieve
        defined?(@@small_sieve) ? @@small_sieve : @@small_sieve= BitSieve.new
      end
      alias_method :attr_small_sieve, :small_sieve
      
      def small_sieve=(value)
        @@small_sieve = value
      end
      alias_method :attr_small_sieve=, :small_sieve=
    }
    
    typesig { [] }
    # Construct a "small sieve" with a base of 0.  This constructor is
    # used internally to generate the set of "small primes" whose multiples
    # are excluded from sieves generated by the main (package private)
    # constructor, BitSieve(BigInteger base, int searchLen).  The length
    # of the sieve generated by this constructor was chosen for performance;
    # it controls a tradeoff between how much time is spent constructing
    # other sieves, and how much time is wasted testing composite candidates
    # for primality.  The length was chosen experimentally to yield good
    # performance.
    def initialize
      @bits = nil
      @length = 0
      @length = 150 * 64
      @bits = Array.typed(::Java::Long).new((unit_index(@length - 1) + 1)) { 0 }
      # Mark 1 as composite
      set(0)
      next_index = 1
      next_prime = 3
      # Find primes and remove their multiples from sieve
      begin
        sieve_single(@length, next_index + next_prime, next_prime)
        next_index = sieve_search(@length, next_index + 1)
        next_prime = 2 * next_index + 1
      end while ((next_index > 0) && (next_prime < @length))
    end
    
    typesig { [BigInteger, ::Java::Int] }
    # Construct a bit sieve of searchLen bits used for finding prime number
    # candidates. The new sieve begins at the specified base, which must
    # be even.
    def initialize(base, search_len)
      @bits = nil
      @length = 0
      # Candidates are indicated by clear bits in the sieve. As a candidates
      # nonprimality is calculated, a bit is set in the sieve to eliminate
      # it. To reduce storage space and increase efficiency, no even numbers
      # are represented in the sieve (each bit in the sieve represents an
      # odd number).
      @bits = Array.typed(::Java::Long).new((unit_index(search_len - 1) + 1)) { 0 }
      @length = search_len
      start = 0
      step = self.attr_small_sieve.sieve_search(self.attr_small_sieve.attr_length, start)
      converted_step = (step * 2) + 1
      # Construct the large sieve at an even offset specified by base
      r = MutableBigInteger.new
      q = MutableBigInteger.new
      begin
        # Calculate base mod convertedStep
        r.copy_value(base.attr_mag)
        r.divide_one_word(converted_step, q)
        start = r.attr_value[r.attr_offset]
        # Take each multiple of step out of sieve
        start = converted_step - start
        if ((start % 2).equal?(0))
          start += converted_step
        end
        sieve_single(search_len, (start - 1) / 2, converted_step)
        # Find next prime from small sieve
        step = self.attr_small_sieve.sieve_search(self.attr_small_sieve.attr_length, step + 1)
        converted_step = (step * 2) + 1
      end while (step > 0)
    end
    
    class_module.module_eval {
      typesig { [::Java::Int] }
      # Given a bit index return unit index containing it.
      def unit_index(bit_index)
        return bit_index >> 6
      end
      
      typesig { [::Java::Int] }
      # Return a unit that masks the specified bit in its unit.
      def bit(bit_index)
        return 1 << (bit_index & ((1 << 6) - 1))
      end
    }
    
    typesig { [::Java::Int] }
    # Get the value of the bit at the specified index.
    def get(bit_index)
      unit_index_ = unit_index(bit_index)
      return (!((@bits[unit_index_] & bit(bit_index))).equal?(0))
    end
    
    typesig { [::Java::Int] }
    # Set the bit at the specified index.
    def set(bit_index)
      unit_index_ = unit_index(bit_index)
      @bits[unit_index_] |= bit(bit_index)
    end
    
    typesig { [::Java::Int, ::Java::Int] }
    # This method returns the index of the first clear bit in the search
    # array that occurs at or after start. It will not search past the
    # specified limit. It returns -1 if there is no such clear bit.
    def sieve_search(limit, start)
      if (start >= limit)
        return -1
      end
      index = start
      begin
        if (!get(index))
          return index
        end
        index += 1
      end while (index < limit - 1)
      return -1
    end
    
    typesig { [::Java::Int, ::Java::Int, ::Java::Int] }
    # Sieve a single set of multiples out of the sieve. Begin to remove
    # multiples of the specified step starting at the specified start index,
    # up to the specified limit.
    def sieve_single(limit, start, step)
      while (start < limit)
        set(start)
        start += step
      end
    end
    
    typesig { [BigInteger, ::Java::Int, Java::Util::Random] }
    # Test probable primes in the sieve and return successful candidates.
    def retrieve(init_value, certainty, random)
      # Examine the sieve one long at a time to find possible primes
      offset = 1
      i = 0
      while i < @bits.attr_length
        next_long = ~@bits[i]
        j = 0
        while j < 64
          if (((next_long & 1)).equal?(1))
            candidate = init_value.add(BigInteger.value_of(offset))
            if (candidate.prime_to_certainty(certainty, random))
              return candidate
            end
          end
          next_long >>= 1
          offset += 2
          j += 1
        end
        i += 1
      end
      return nil
    end
    
    private
    alias_method :initialize__bit_sieve, :initialize
  end
  
end
