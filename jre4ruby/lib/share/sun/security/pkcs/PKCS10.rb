require "rjava"

# Copyright 1996-2002 Sun Microsystems, Inc.  All Rights Reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
# 
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Sun designates this
# particular file as subject to the "Classpath" exception as provided
# by Sun in the LICENSE file that accompanied this code.
# 
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
# 
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
# 
# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
# CA 95054 USA or visit www.sun.com if you need additional information or
# have any questions.
module Sun::Security::Pkcs
  module PKCS10Imports #:nodoc:
    class_module.module_eval {
      include ::Java::Lang
      include ::Sun::Security::Pkcs
      include_const ::Java::Io, :ByteArrayOutputStream
      include_const ::Java::Io, :PrintStream
      include_const ::Java::Io, :IOException
      include_const ::Java::Math, :BigInteger
      include_const ::Java::Security::Cert, :CertificateException
      include_const ::Java::Security, :NoSuchAlgorithmException
      include_const ::Java::Security, :InvalidKeyException
      include_const ::Java::Security, :Signature
      include_const ::Java::Security, :SignatureException
      include_const ::Java::Security, :PublicKey
      include_const ::Sun::Misc, :BASE64Encoder
      include ::Sun::Security::Util
      include_const ::Sun::Security::X509, :AlgorithmId
      include_const ::Sun::Security::X509, :X509Key
      include_const ::Sun::Security::X509, :X500Name
      include_const ::Sun::Security::X509, :X500Signer
    }
  end
  
  # signed
  # 
  # A PKCS #10 certificate request is created and sent to a Certificate
  # Authority, which then creates an X.509 certificate and returns it to
  # the entity that requested it. A certificate request basically consists
  # of the subject's X.500 name, public key, and optionally some attributes,
  # signed using the corresponding private key.
  # 
  # The ASN.1 syntax for a Certification Request is:
  # <pre>
  # CertificationRequest ::= SEQUENCE {
  # certificationRequestInfo CertificationRequestInfo,
  # signatureAlgorithm       SignatureAlgorithmIdentifier,
  # signature                Signature
  # }
  # 
  # SignatureAlgorithmIdentifier ::= AlgorithmIdentifier
  # Signature ::= BIT STRING
  # 
  # CertificationRequestInfo ::= SEQUENCE {
  # version                 Version,
  # subject                 Name,
  # subjectPublicKeyInfo    SubjectPublicKeyInfo,
  # attributes [0] IMPLICIT Attributes
  # }
  # Attributes ::= SET OF Attribute
  # </pre>
  # 
  # @author David Brownell
  # @author Amit Kapoor
  # @author Hemma Prafullchandra
  class PKCS10 
    include_class_members PKCS10Imports
    
    typesig { [PublicKey] }
    # Constructs an unsigned PKCS #10 certificate request.  Before this
    # request may be used, it must be encoded and signed.  Then it
    # must be retrieved in some conventional format (e.g. string).
    # 
    # @param publicKey the public key that should be placed
    # into the certificate generated by the CA.
    def initialize(public_key)
      @subject = nil
      @subject_public_key_info = nil
      @attribute_set = nil
      @encoded = nil
      @subject_public_key_info = public_key
      @attribute_set = PKCS10Attributes.new
    end
    
    typesig { [PublicKey, PKCS10Attributes] }
    # Constructs an unsigned PKCS #10 certificate request.  Before this
    # request may be used, it must be encoded and signed.  Then it
    # must be retrieved in some conventional format (e.g. string).
    # 
    # @param publicKey the public key that should be placed
    # into the certificate generated by the CA.
    # @param attributes additonal set of PKCS10 attributes requested
    # for in the certificate.
    def initialize(public_key, attributes)
      @subject = nil
      @subject_public_key_info = nil
      @attribute_set = nil
      @encoded = nil
      @subject_public_key_info = public_key
      @attribute_set = attributes
    end
    
    typesig { [Array.typed(::Java::Byte)] }
    # Parses an encoded, signed PKCS #10 certificate request, verifying
    # the request's signature as it does so.  This constructor would
    # typically be used by a Certificate Authority, from which a new
    # certificate would then be constructed.
    # 
    # @param data the DER-encoded PKCS #10 request.
    # @exception IOException for low level errors reading the data
    # @exception SignatureException when the signature is invalid
    # @exception NoSuchAlgorithmException when the signature
    # algorithm is not supported in this environment
    def initialize(data)
      @subject = nil
      @subject_public_key_info = nil
      @attribute_set = nil
      @encoded = nil
      in_ = nil
      seq = nil
      id = nil
      sig_data = nil
      sig = nil
      @encoded = data
      # Outer sequence:  request, signature algorithm, signature.
      # Parse, and prepare to verify later.
      in_ = DerInputStream.new(data)
      seq = in_.get_sequence(3)
      if (!(seq.attr_length).equal?(3))
        raise IllegalArgumentException.new("not a PKCS #10 request")
      end
      data = seq[0].to_byte_array # reusing this variable
      id = AlgorithmId.parse(seq[1])
      sig_data = seq[2].get_bit_string
      # Inner sequence:  version, name, key, attributes
      serial = nil
      val = nil
      serial = seq[0].attr_data.get_big_integer
      if (!(serial == BigInteger::ZERO))
        raise IllegalArgumentException.new("not PKCS #10 v1")
      end
      @subject = X500Name.new(seq[0].attr_data)
      @subject_public_key_info = X509Key.parse(seq[0].attr_data.get_der_value)
      # Cope with a somewhat common illegal PKCS #10 format
      if (!(seq[0].attr_data.available).equal?(0))
        @attribute_set = PKCS10Attributes.new(seq[0].attr_data)
      else
        @attribute_set = PKCS10Attributes.new
      end
      if (!(seq[0].attr_data.available).equal?(0))
        raise IllegalArgumentException.new("illegal PKCS #10 data")
      end
      # OK, we parsed it all ... validate the signature using the
      # key and signature algorithm we found.
      begin
        sig = Signature.get_instance(id.get_name)
        sig.init_verify(@subject_public_key_info)
        sig.update(data)
        if (!sig.verify(sig_data))
          raise SignatureException.new("Invalid PKCS #10 signature")
        end
      rescue InvalidKeyException => e
        raise SignatureException.new("invalid key")
      end
    end
    
    typesig { [X500Signer] }
    # Create the signed certificate request.  This will later be
    # retrieved in either string or binary format.
    # 
    # @param requester identifies the signer (by X.500 name)
    # and provides the private key used to sign.
    # @exception IOException on errors.
    # @exception CertificateException on certificate handling errors.
    # @exception SignatureException on signature handling errors.
    def encode_and_sign(requester)
      out = nil
      scratch = nil
      certificate_request_info = nil
      sig = nil
      if (!(@encoded).nil?)
        raise SignatureException.new("request is already signed")
      end
      @subject = requester.get_signer
      # Encode cert request info, wrap in a sequence for signing
      scratch = DerOutputStream.new
      scratch.put_integer(BigInteger::ZERO) # PKCS #10 v1.0
      @subject.encode(scratch) # X.500 name
      scratch.write(@subject_public_key_info.get_encoded) # public key
      @attribute_set.encode(scratch)
      out = DerOutputStream.new
      out.write(DerValue.attr_tag_sequence, scratch) # wrap it!
      certificate_request_info = out.to_byte_array
      scratch = out
      # Sign it ...
      requester.update(certificate_request_info, 0, certificate_request_info.attr_length)
      sig = requester.sign
      # Build guts of SIGNED macro
      requester.get_algorithm_id.encode(scratch) # sig algorithm
      scratch.put_bit_string(sig) # sig
      # Wrap those guts in a sequence
      out = DerOutputStream.new
      out.write(DerValue.attr_tag_sequence, scratch)
      @encoded = out.to_byte_array
    end
    
    typesig { [] }
    # Returns the subject's name.
    def get_subject_name
      return @subject
    end
    
    typesig { [] }
    # Returns the subject's public key.
    def get_subject_public_key_info
      return @subject_public_key_info
    end
    
    typesig { [] }
    # Returns the additional attributes requested.
    def get_attributes
      return @attribute_set
    end
    
    typesig { [] }
    # Returns the encoded and signed certificate request as a
    # DER-encoded byte array.
    # 
    # @return the certificate request, or null if encodeAndSign()
    # has not yet been called.
    def get_encoded
      if (!(@encoded).nil?)
        return @encoded.clone
      else
        return nil
      end
    end
    
    typesig { [PrintStream] }
    # Prints an E-Mailable version of the certificate request on the print
    # stream passed.  The format is a common base64 encoded one, supported
    # by most Certificate Authorities because Netscape web servers have
    # used this for some time.  Some certificate authorities expect some
    # more information, in particular contact information for the web
    # server administrator.
    # 
    # @param out the print stream where the certificate request
    # will be printed.
    # @exception IOException when an output operation failed
    # @exception SignatureException when the certificate request was
    # not yet signed.
    def print(out)
      if ((@encoded).nil?)
        raise SignatureException.new("Cert request was not signed")
      end
      encoder = BASE64Encoder.new
      out.println("-----BEGIN NEW CERTIFICATE REQUEST-----")
      encoder.encode_buffer(@encoded, out)
      out.println("-----END NEW CERTIFICATE REQUEST-----")
    end
    
    typesig { [] }
    # Provides a short description of this request.
    def to_s
      return "[PKCS #10 certificate request:\n" + RJava.cast_to_string(@subject_public_key_info.to_s) + " subject: <" + RJava.cast_to_string(@subject) + ">" + "\n" + " attributes: " + RJava.cast_to_string(@attribute_set.to_s) + "\n]"
    end
    
    typesig { [Object] }
    # Compares this object for equality with the specified
    # object. If the <code>other</code> object is an
    # <code>instanceof</code> <code>PKCS10</code>, then
    # its encoded form is retrieved and compared with the
    # encoded form of this certificate request.
    # 
    # @param other the object to test for equality with this object.
    # @return true iff the encoded forms of the two certificate
    # requests match, false otherwise.
    def ==(other)
      if ((self).equal?(other))
        return true
      end
      if (!(other.is_a?(PKCS10)))
        return false
      end
      if ((@encoded).nil?)
        # not signed yet
        return false
      end
      other_encoded = (other).get_encoded
      if ((other_encoded).nil?)
        return false
      end
      return (Java::Util::Arrays == @encoded)
    end
    
    typesig { [] }
    # Returns a hashcode value for this certificate request from its
    # encoded form.
    # 
    # @return the hashcode value.
    def hash_code
      retval = 0
      if (!(@encoded).nil?)
        i = 1
        while i < @encoded.attr_length
          retval += @encoded[i] * i
          i += 1
        end
      end
      return (retval)
    end
    
    attr_accessor :subject
    alias_method :attr_subject, :subject
    undef_method :subject
    alias_method :attr_subject=, :subject=
    undef_method :subject=
    
    attr_accessor :subject_public_key_info
    alias_method :attr_subject_public_key_info, :subject_public_key_info
    undef_method :subject_public_key_info
    alias_method :attr_subject_public_key_info=, :subject_public_key_info=
    undef_method :subject_public_key_info=
    
    attr_accessor :attribute_set
    alias_method :attr_attribute_set, :attribute_set
    undef_method :attribute_set
    alias_method :attr_attribute_set=, :attribute_set=
    undef_method :attribute_set=
    
    attr_accessor :encoded
    alias_method :attr_encoded, :encoded
    undef_method :encoded
    alias_method :attr_encoded=, :encoded=
    undef_method :encoded=
    
    private
    alias_method :initialize__pkcs10, :initialize
  end
  
end
