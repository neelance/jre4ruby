require "rjava"

# Copyright 2001 Sun Microsystems, Inc.  All Rights Reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
# 
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Sun designates this
# particular file as subject to the "Classpath" exception as provided
# by Sun in the LICENSE file that accompanied this code.
# 
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
# 
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
# 
# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
# CA 95054 USA or visit www.sun.com if you need additional information or
# have any questions.
module Sun::Reflect
  module MethodAccessorGeneratorImports #:nodoc:
    class_module.module_eval {
      include ::Java::Lang
      include ::Sun::Reflect
      include ::Java::Lang::Reflect
      include_const ::Java::Security, :AccessController
      include_const ::Java::Security, :PrivilegedAction
      include_const ::Sun::Misc, :Unsafe
    }
  end
  
  # Generator for sun.reflect.MethodAccessor and
  # sun.reflect.ConstructorAccessor objects using bytecodes to
  # implement reflection. A java.lang.reflect.Method or
  # java.lang.reflect.Constructor object can delegate its invoke or
  # newInstance method to an accessor using native code or to one
  # generated by this class. (Methods and Constructors were merged
  # together in this class to ensure maximum code sharing.)
  class MethodAccessorGenerator < MethodAccessorGeneratorImports.const_get :AccessorGenerator
    include_class_members MethodAccessorGeneratorImports
    
    class_module.module_eval {
      const_set_lazy(:NUM_BASE_CPOOL_ENTRIES) { RJava.cast_to_short(12) }
      const_attr_reader  :NUM_BASE_CPOOL_ENTRIES
      
      # One for invoke() plus one for constructor
      const_set_lazy(:NUM_METHODS) { RJava.cast_to_short(2) }
      const_attr_reader  :NUM_METHODS
      
      # Only used if forSerialization is true
      const_set_lazy(:NUM_SERIALIZATION_CPOOL_ENTRIES) { RJava.cast_to_short(2) }
      const_attr_reader  :NUM_SERIALIZATION_CPOOL_ENTRIES
      
      
      def method_symnum
        defined?(@@method_symnum) ? @@method_symnum : @@method_symnum= 0
      end
      alias_method :attr_method_symnum, :method_symnum
      
      def method_symnum=(value)
        @@method_symnum = value
      end
      alias_method :attr_method_symnum=, :method_symnum=
      
      
      def constructor_symnum
        defined?(@@constructor_symnum) ? @@constructor_symnum : @@constructor_symnum= 0
      end
      alias_method :attr_constructor_symnum, :constructor_symnum
      
      def constructor_symnum=(value)
        @@constructor_symnum = value
      end
      alias_method :attr_constructor_symnum=, :constructor_symnum=
      
      
      def serialization_constructor_symnum
        defined?(@@serialization_constructor_symnum) ? @@serialization_constructor_symnum : @@serialization_constructor_symnum= 0
      end
      alias_method :attr_serialization_constructor_symnum, :serialization_constructor_symnum
      
      def serialization_constructor_symnum=(value)
        @@serialization_constructor_symnum = value
      end
      alias_method :attr_serialization_constructor_symnum=, :serialization_constructor_symnum=
    }
    
    attr_accessor :declaring_class
    alias_method :attr_declaring_class, :declaring_class
    undef_method :declaring_class
    alias_method :attr_declaring_class=, :declaring_class=
    undef_method :declaring_class=
    
    attr_accessor :parameter_types
    alias_method :attr_parameter_types, :parameter_types
    undef_method :parameter_types
    alias_method :attr_parameter_types=, :parameter_types=
    undef_method :parameter_types=
    
    attr_accessor :return_type
    alias_method :attr_return_type, :return_type
    undef_method :return_type
    alias_method :attr_return_type=, :return_type=
    undef_method :return_type=
    
    attr_accessor :is_constructor
    alias_method :attr_is_constructor, :is_constructor
    undef_method :is_constructor
    alias_method :attr_is_constructor=, :is_constructor=
    undef_method :is_constructor=
    
    attr_accessor :for_serialization
    alias_method :attr_for_serialization, :for_serialization
    undef_method :for_serialization
    alias_method :attr_for_serialization=, :for_serialization=
    undef_method :for_serialization=
    
    attr_accessor :target_method_ref
    alias_method :attr_target_method_ref, :target_method_ref
    undef_method :target_method_ref
    alias_method :attr_target_method_ref=, :target_method_ref=
    undef_method :target_method_ref=
    
    attr_accessor :invoke_idx
    alias_method :attr_invoke_idx, :invoke_idx
    undef_method :invoke_idx
    alias_method :attr_invoke_idx=, :invoke_idx=
    undef_method :invoke_idx=
    
    attr_accessor :invoke_descriptor_idx
    alias_method :attr_invoke_descriptor_idx, :invoke_descriptor_idx
    undef_method :invoke_descriptor_idx
    alias_method :attr_invoke_descriptor_idx=, :invoke_descriptor_idx=
    undef_method :invoke_descriptor_idx=
    
    # Constant pool index of CONSTANT_Class_info for first
    # non-primitive parameter type. Should be incremented by 2.
    attr_accessor :non_primitive_parameters_base_idx
    alias_method :attr_non_primitive_parameters_base_idx, :non_primitive_parameters_base_idx
    undef_method :non_primitive_parameters_base_idx
    alias_method :attr_non_primitive_parameters_base_idx=, :non_primitive_parameters_base_idx=
    undef_method :non_primitive_parameters_base_idx=
    
    typesig { [] }
    def initialize
      @declaring_class = nil
      @parameter_types = nil
      @return_type = nil
      @is_constructor = false
      @for_serialization = false
      @target_method_ref = 0
      @invoke_idx = 0
      @invoke_descriptor_idx = 0
      @non_primitive_parameters_base_idx = 0
      super()
    end
    
    typesig { [Class, String, Array.typed(Class), Class, Array.typed(Class), ::Java::Int] }
    # This routine is not thread-safe
    def generate_method(declaring_class, name, parameter_types, return_type, checked_exceptions, modifiers)
      return generate(declaring_class, name, parameter_types, return_type, checked_exceptions, modifiers, false, false, nil)
    end
    
    typesig { [Class, Array.typed(Class), Array.typed(Class), ::Java::Int] }
    # This routine is not thread-safe
    def generate_constructor(declaring_class, parameter_types, checked_exceptions, modifiers)
      return generate(declaring_class, "<init>", parameter_types, Void::TYPE, checked_exceptions, modifiers, true, false, nil)
    end
    
    typesig { [Class, Array.typed(Class), Array.typed(Class), ::Java::Int, Class] }
    # This routine is not thread-safe
    def generate_serialization_constructor(declaring_class, parameter_types, checked_exceptions, modifiers, target_constructor_class)
      return generate(declaring_class, "<init>", parameter_types, Void::TYPE, checked_exceptions, modifiers, true, true, target_constructor_class)
    end
    
    typesig { [Class, String, Array.typed(Class), Class, Array.typed(Class), ::Java::Int, ::Java::Boolean, ::Java::Boolean, Class] }
    # This routine is not thread-safe
    def generate(declaring_class, name, parameter_types, return_type, checked_exceptions, modifiers, is_constructor, for_serialization, serialization_target_class)
      vec = ByteVectorFactory.create
      self.attr_asm = ClassFileAssembler.new(vec)
      @declaring_class = declaring_class
      @parameter_types = parameter_types
      @return_type = return_type
      self.attr_modifiers = modifiers
      @is_constructor = is_constructor
      @for_serialization = for_serialization
      self.attr_asm.emit_magic_and_version
      # Constant pool entries:
      # ( * = Boxing information: optional)
      # (+  = Shared entries provided by AccessorGenerator)
      # (^  = Only present if generating SerializationConstructorAccessor)
      # [UTF-8] [This class's name]
      # [CONSTANT_Class_info] for above
      # [UTF-8] "sun/reflect/{MethodAccessorImpl,ConstructorAccessorImpl,SerializationConstructorAccessorImpl}"
      # [CONSTANT_Class_info] for above
      # [UTF-8] [Target class's name]
      # [CONSTANT_Class_info] for above
      # ^   [UTF-8] [Serialization: Class's name in which to invoke constructor]
      # ^   [CONSTANT_Class_info] for above
      # [UTF-8] target method or constructor name
      # [UTF-8] target method or constructor signature
      # [CONSTANT_NameAndType_info] for above
      # [CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info] for target method
      # [UTF-8] "invoke" or "newInstance"
      # [UTF-8] invoke or newInstance descriptor
      # [UTF-8] descriptor for type of non-primitive parameter 1
      # [CONSTANT_Class_info] for type of non-primitive parameter 1
      # ...
      # [UTF-8] descriptor for type of non-primitive parameter n
      # [CONSTANT_Class_info] for type of non-primitive parameter n
      # +   [UTF-8] "java/lang/Exception"
      # +   [CONSTANT_Class_info] for above
      # +   [UTF-8] "java/lang/ClassCastException"
      # +   [CONSTANT_Class_info] for above
      # +   [UTF-8] "java/lang/NullPointerException"
      # +   [CONSTANT_Class_info] for above
      # +   [UTF-8] "java/lang/IllegalArgumentException"
      # +   [CONSTANT_Class_info] for above
      # +   [UTF-8] "java/lang/InvocationTargetException"
      # +   [CONSTANT_Class_info] for above
      # +   [UTF-8] "<init>"
      # +   [UTF-8] "()V"
      # +   [CONSTANT_NameAndType_info] for above
      # +   [CONSTANT_Methodref_info] for NullPointerException's constructor
      # +   [CONSTANT_Methodref_info] for IllegalArgumentException's constructor
      # +   [UTF-8] "(Ljava/lang/String;)V"
      # +   [CONSTANT_NameAndType_info] for "<init>(Ljava/lang/String;)V"
      # +   [CONSTANT_Methodref_info] for IllegalArgumentException's constructor taking a String
      # +   [UTF-8] "(Ljava/lang/Throwable;)V"
      # +   [CONSTANT_NameAndType_info] for "<init>(Ljava/lang/Throwable;)V"
      # +   [CONSTANT_Methodref_info] for InvocationTargetException's constructor
      # +   [CONSTANT_Methodref_info] for "super()"
      # +   [UTF-8] "java/lang/Object"
      # +   [CONSTANT_Class_info] for above
      # +   [UTF-8] "toString"
      # +   [UTF-8] "()Ljava/lang/String;"
      # +   [CONSTANT_NameAndType_info] for "toString()Ljava/lang/String;"
      # +   [CONSTANT_Methodref_info] for Object's toString method
      # +   [UTF-8] "Code"
      # +   [UTF-8] "Exceptions"
      # *  [UTF-8] "java/lang/Boolean"
      # *  [CONSTANT_Class_info] for above
      # *  [UTF-8] "(Z)V"
      # *  [CONSTANT_NameAndType_info] for above
      # *  [CONSTANT_Methodref_info] for above
      # *  [UTF-8] "booleanValue"
      # *  [UTF-8] "()Z"
      # *  [CONSTANT_NameAndType_info] for above
      # *  [CONSTANT_Methodref_info] for above
      # *  [UTF-8] "java/lang/Byte"
      # *  [CONSTANT_Class_info] for above
      # *  [UTF-8] "(B)V"
      # *  [CONSTANT_NameAndType_info] for above
      # *  [CONSTANT_Methodref_info] for above
      # *  [UTF-8] "byteValue"
      # *  [UTF-8] "()B"
      # *  [CONSTANT_NameAndType_info] for above
      # *  [CONSTANT_Methodref_info] for above
      # *  [UTF-8] "java/lang/Character"
      # *  [CONSTANT_Class_info] for above
      # *  [UTF-8] "(C)V"
      # *  [CONSTANT_NameAndType_info] for above
      # *  [CONSTANT_Methodref_info] for above
      # *  [UTF-8] "charValue"
      # *  [UTF-8] "()C"
      # *  [CONSTANT_NameAndType_info] for above
      # *  [CONSTANT_Methodref_info] for above
      # *  [UTF-8] "java/lang/Double"
      # *  [CONSTANT_Class_info] for above
      # *  [UTF-8] "(D)V"
      # *  [CONSTANT_NameAndType_info] for above
      # *  [CONSTANT_Methodref_info] for above
      # *  [UTF-8] "doubleValue"
      # *  [UTF-8] "()D"
      # *  [CONSTANT_NameAndType_info] for above
      # *  [CONSTANT_Methodref_info] for above
      # *  [UTF-8] "java/lang/Float"
      # *  [CONSTANT_Class_info] for above
      # *  [UTF-8] "(F)V"
      # *  [CONSTANT_NameAndType_info] for above
      # *  [CONSTANT_Methodref_info] for above
      # *  [UTF-8] "floatValue"
      # *  [UTF-8] "()F"
      # *  [CONSTANT_NameAndType_info] for above
      # *  [CONSTANT_Methodref_info] for above
      # *  [UTF-8] "java/lang/Integer"
      # *  [CONSTANT_Class_info] for above
      # *  [UTF-8] "(I)V"
      # *  [CONSTANT_NameAndType_info] for above
      # *  [CONSTANT_Methodref_info] for above
      # *  [UTF-8] "intValue"
      # *  [UTF-8] "()I"
      # *  [CONSTANT_NameAndType_info] for above
      # *  [CONSTANT_Methodref_info] for above
      # *  [UTF-8] "java/lang/Long"
      # *  [CONSTANT_Class_info] for above
      # *  [UTF-8] "(J)V"
      # *  [CONSTANT_NameAndType_info] for above
      # *  [CONSTANT_Methodref_info] for above
      # *  [UTF-8] "longValue"
      # *  [UTF-8] "()J"
      # *  [CONSTANT_NameAndType_info] for above
      # *  [CONSTANT_Methodref_info] for above
      # *  [UTF-8] "java/lang/Short"
      # *  [CONSTANT_Class_info] for above
      # *  [UTF-8] "(S)V"
      # *  [CONSTANT_NameAndType_info] for above
      # *  [CONSTANT_Methodref_info] for above
      # *  [UTF-8] "shortValue"
      # *  [UTF-8] "()S"
      # *  [CONSTANT_NameAndType_info] for above
      # *  [CONSTANT_Methodref_info] for above
      num_cpentries = NUM_BASE_CPOOL_ENTRIES + NUM_COMMON_CPOOL_ENTRIES
      uses_primitives = uses_primitive_types
      if (uses_primitives)
        num_cpentries += NUM_BOXING_CPOOL_ENTRIES
      end
      if (for_serialization)
        num_cpentries += NUM_SERIALIZATION_CPOOL_ENTRIES
      end
      # Add in variable-length number of entries to be able to describe
      # non-primitive parameter types and checked exceptions.
      num_cpentries += RJava.cast_to_short((2 * num_non_primitive_parameter_types))
      self.attr_asm.emit_short(add(num_cpentries, S1))
      generated_name = generate_name(is_constructor, for_serialization)
      self.attr_asm.emit_constant_pool_utf8(generated_name)
      self.attr_asm.emit_constant_pool_class(self.attr_asm.cpi)
      self.attr_this_class = self.attr_asm.cpi
      if (is_constructor)
        if (for_serialization)
          self.attr_asm.emit_constant_pool_utf8("sun/reflect/SerializationConstructorAccessorImpl")
        else
          self.attr_asm.emit_constant_pool_utf8("sun/reflect/ConstructorAccessorImpl")
        end
      else
        self.attr_asm.emit_constant_pool_utf8("sun/reflect/MethodAccessorImpl")
      end
      self.attr_asm.emit_constant_pool_class(self.attr_asm.cpi)
      self.attr_super_class = self.attr_asm.cpi
      self.attr_asm.emit_constant_pool_utf8(get_class_name(declaring_class, false))
      self.attr_asm.emit_constant_pool_class(self.attr_asm.cpi)
      self.attr_target_class = self.attr_asm.cpi
      serialization_target_class_idx = RJava.cast_to_short(0)
      if (for_serialization)
        self.attr_asm.emit_constant_pool_utf8(get_class_name(serialization_target_class, false))
        self.attr_asm.emit_constant_pool_class(self.attr_asm.cpi)
        serialization_target_class_idx = self.attr_asm.cpi
      end
      self.attr_asm.emit_constant_pool_utf8(name)
      self.attr_asm.emit_constant_pool_utf8(build_internal_signature)
      self.attr_asm.emit_constant_pool_name_and_type(sub(self.attr_asm.cpi, S1), self.attr_asm.cpi)
      if (is_interface)
        self.attr_asm.emit_constant_pool_interface_methodref(self.attr_target_class, self.attr_asm.cpi)
      else
        if (for_serialization)
          self.attr_asm.emit_constant_pool_methodref(serialization_target_class_idx, self.attr_asm.cpi)
        else
          self.attr_asm.emit_constant_pool_methodref(self.attr_target_class, self.attr_asm.cpi)
        end
      end
      @target_method_ref = self.attr_asm.cpi
      if (is_constructor)
        self.attr_asm.emit_constant_pool_utf8("newInstance")
      else
        self.attr_asm.emit_constant_pool_utf8("invoke")
      end
      @invoke_idx = self.attr_asm.cpi
      if (is_constructor)
        self.attr_asm.emit_constant_pool_utf8("([Ljava/lang/Object;)Ljava/lang/Object;")
      else
        self.attr_asm.emit_constant_pool_utf8("(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;")
      end
      @invoke_descriptor_idx = self.attr_asm.cpi
      # Output class information for non-primitive parameter types
      @non_primitive_parameters_base_idx = add(self.attr_asm.cpi, S2)
      i = 0
      while i < parameter_types.attr_length
        c = parameter_types[i]
        if (!is_primitive(c))
          self.attr_asm.emit_constant_pool_utf8(get_class_name(c, false))
          self.attr_asm.emit_constant_pool_class(self.attr_asm.cpi)
        end
        i += 1
      end
      # Entries common to FieldAccessor, MethodAccessor and ConstructorAccessor
      emit_common_constant_pool_entries
      # Boxing entries
      if (uses_primitives)
        emit_boxing_contant_pool_entries
      end
      if (!(self.attr_asm.cpi).equal?(num_cpentries))
        raise InternalError.new("Adjust this code (cpi = " + RJava.cast_to_string(self.attr_asm.cpi) + ", numCPEntries = " + RJava.cast_to_string(num_cpentries) + ")")
      end
      # Access flags
      self.attr_asm.emit_short(ACC_PUBLIC)
      # This class
      self.attr_asm.emit_short(self.attr_this_class)
      # Superclass
      self.attr_asm.emit_short(self.attr_super_class)
      # Interfaces count and interfaces
      self.attr_asm.emit_short(S0)
      # Fields count and fields
      self.attr_asm.emit_short(S0)
      # Methods count and methods
      self.attr_asm.emit_short(NUM_METHODS)
      emit_constructor
      emit_invoke
      # Additional attributes (none)
      self.attr_asm.emit_short(S0)
      # Load class
      vec.trim
      bytes = vec.get_data
      return AccessController.do_privileged(# Note: the class loader is the only thing that really matters
      # here -- it's important to get the generated code into the
      # same namespace as the target class. Since the generated code
      # is privileged anyway, the protection domain probably doesn't
      # matter.
      Class.new(PrivilegedAction.class == Class ? PrivilegedAction : Object) do
        extend LocalClass
        include_class_members MethodAccessorGenerator
        include PrivilegedAction if PrivilegedAction.class == Module
        
        typesig { [] }
        define_method :run do
          begin
            return ClassDefiner.define_class(generated_name, bytes, 0, bytes.attr_length, declaring_class.get_class_loader).new_instance
          rescue self.class::InstantiationException => e
            raise self.class::InternalError.new.init_cause(e)
          rescue self.class::IllegalAccessException => e
            raise self.class::InternalError.new.init_cause(e)
          end
        end
        
        typesig { [] }
        define_method :initialize do
          super()
        end
        
        private
        alias_method :initialize_anonymous, :initialize
      end.new_local(self))
    end
    
    typesig { [] }
    # This emits the code for either invoke() or newInstance()
    def emit_invoke
      # NOTE that this code will only handle 65535 parameters since we
      # use the sipush instruction to get the array index on the
      # operand stack.
      if (@parameter_types.attr_length > 65535)
        raise InternalError.new("Can't handle more than 65535 parameters")
      end
      # Generate code into fresh code buffer
      cb = ClassFileAssembler.new
      if (@is_constructor)
        # 1 incoming argument
        cb.set_max_locals(2)
      else
        # 2 incoming arguments
        cb.set_max_locals(3)
      end
      illegal_arg_start_pc = 0
      if (@is_constructor)
        # Instantiate target class before continuing
        # new <target class type>
        # dup
        cb.opc_new(self.attr_target_class)
        cb.opc_dup
      else
        # Setup before iterating down argument list
        if (is_primitive(@return_type))
          # new <boxing type for primitive type>
          # dup
          # ... (see below:)
          # invokespecial <constructor for boxing type for primitive type>
          # areturn
          cb.opc_new(index_for_primitive_type(@return_type))
          cb.opc_dup
        end
        # Get target object on operand stack if necessary.
        # We need to do an explicit null check here; we won't see
        # NullPointerExceptions from the invoke bytecode, since it's
        # covered by an exception handler.
        if (!is_static)
          # aload_1
          # ifnonnull <checkcast label>
          # new <NullPointerException>
          # dup
          # invokespecial <NullPointerException ctor>
          # athrow
          # <checkcast label:>
          # aload_1
          # checkcast <target class's type>
          cb.opc_aload_1
          l = Label.new
          cb.opc_ifnonnull(l)
          cb.opc_new(self.attr_null_pointer_class)
          cb.opc_dup
          cb.opc_invokespecial(self.attr_null_pointer_ctor_idx, 0, 0)
          cb.opc_athrow
          l.bind
          illegal_arg_start_pc = cb.get_length
          cb.opc_aload_1
          cb.opc_checkcast(self.attr_target_class)
        end
      end
      # Have to check length of incoming array and throw
      # IllegalArgumentException if not correct. A concession to the
      # JCK (isn't clearly specified in the spec): we allow null in the
      # case where the argument list is zero length.
      # if no-arg:
      # aload_2 | aload_1 (Method | Constructor)
      # ifnull <success label>
      # aload_2 | aload_1
      # arraylength
      # sipush <num parameter types>
      # if_icmpeq <success label>
      # new <IllegalArgumentException>
      # dup
      # invokespecial <IllegalArgumentException ctor>
      # athrow
      # <success label:>
      success_label = Label.new
      if ((@parameter_types.attr_length).equal?(0))
        if (@is_constructor)
          cb.opc_aload_1
        else
          cb.opc_aload_2
        end
        cb.opc_ifnull(success_label)
      end
      if (@is_constructor)
        cb.opc_aload_1
      else
        cb.opc_aload_2
      end
      cb.opc_arraylength
      cb.opc_sipush(RJava.cast_to_short(@parameter_types.attr_length))
      cb.opc_if_icmpeq(success_label)
      cb.opc_new(self.attr_illegal_argument_class)
      cb.opc_dup
      cb.opc_invokespecial(self.attr_illegal_argument_ctor_idx, 0, 0)
      cb.opc_athrow
      success_label.bind
      # Iterate through incoming actual parameters, ensuring that each
      # is compatible with the formal parameter type, and pushing the
      # actual on the operand stack (unboxing and widening if necessary).
      param_type_cpidx = @non_primitive_parameters_base_idx
      next_param_label = nil
      count = 1 # both invokeinterface opcode's "count" as well as
      # num args of other invoke bytecodes
      i = 0
      while i < @parameter_types.attr_length
        param_type = @parameter_types[i]
        count += type_size_in_stack_slots(param_type)
        if (!(next_param_label).nil?)
          next_param_label.bind
          next_param_label = nil
        end
        # aload_2 | aload_1
        # sipush <index>
        # aaload
        if (@is_constructor)
          cb.opc_aload_1
        else
          cb.opc_aload_2
        end
        cb.opc_sipush(RJava.cast_to_short(i))
        cb.opc_aaload
        if (is_primitive(param_type))
          # Unboxing code.
          # Put parameter into temporary local variable
          # astore_3 | astore_2
          if (@is_constructor)
            cb.opc_astore_2
          else
            cb.opc_astore_3
          end
          # repeat for all possible widening conversions:
          # aload_3 | aload_2
          # instanceof <primitive boxing type>
          # ifeq <next unboxing label>
          # aload_3 | aload_2
          # checkcast <primitive boxing type> // Note: this is "redundant",
          # // but necessary for the verifier
          # invokevirtual <unboxing method>
          # <widening conversion bytecode, if necessary>
          # goto <next parameter label>
          # <next unboxing label:> ...
          # last unboxing label:
          # new <IllegalArgumentException>
          # dup
          # invokespecial <IllegalArgumentException ctor>
          # athrow
          l = nil # unboxing label
          next_param_label = Label.new
          j = 0
          while j < self.attr_primitive_types.attr_length
            c = self.attr_primitive_types[j]
            if (can_widen_to(c, param_type))
              if (!(l).nil?)
                l.bind
              end
              # Emit checking and unboxing code for this type
              if (@is_constructor)
                cb.opc_aload_2
              else
                cb.opc_aload_3
              end
              cb.opc_instanceof(index_for_primitive_type(c))
              l = Label.new
              cb.opc_ifeq(l)
              if (@is_constructor)
                cb.opc_aload_2
              else
                cb.opc_aload_3
              end
              cb.opc_checkcast(index_for_primitive_type(c))
              cb.opc_invokevirtual(unboxing_method_for_primitive_type(c), 0, type_size_in_stack_slots(c))
              emit_widening_bytecode_for_primitive_conversion(cb, c, param_type)
              cb.opc_goto(next_param_label)
            end
            j += 1
          end
          if ((l).nil?)
            raise InternalError.new("Must have found at least identity conversion")
          end
          # Fell through; given object is null or invalid. According to
          # the spec, we can throw IllegalArgumentException for both of
          # these cases.
          l.bind
          cb.opc_new(self.attr_illegal_argument_class)
          cb.opc_dup
          cb.opc_invokespecial(self.attr_illegal_argument_ctor_idx, 0, 0)
          cb.opc_athrow
        else
          # Emit appropriate checkcast
          cb.opc_checkcast(param_type_cpidx)
          param_type_cpidx = add(param_type_cpidx, S2)
          # Fall through to next argument
        end
        i += 1
      end
      # Bind last goto if present
      if (!(next_param_label).nil?)
        next_param_label.bind
      end
      invoke_start_pc = cb.get_length
      # OK, ready to perform the invocation.
      if (@is_constructor)
        cb.opc_invokespecial(@target_method_ref, count, 0)
      else
        if (is_static)
          cb.opc_invokestatic(@target_method_ref, count, type_size_in_stack_slots(@return_type))
        else
          if (is_interface)
            cb.opc_invokeinterface(@target_method_ref, count, count, type_size_in_stack_slots(@return_type))
          else
            cb.opc_invokevirtual(@target_method_ref, count, type_size_in_stack_slots(@return_type))
          end
        end
      end
      invoke_end_pc = cb.get_length
      if (!@is_constructor)
        # Box return value if necessary
        if (is_primitive(@return_type))
          cb.opc_invokespecial(ctor_index_for_primitive_type(@return_type), type_size_in_stack_slots(@return_type), 0)
        else
          if ((@return_type).equal?(Void::TYPE))
            cb.opc_aconst_null
          end
        end
      end
      cb.opc_areturn
      # We generate two exception handlers; one which is responsible
      # for catching ClassCastException and NullPointerException and
      # throwing IllegalArgumentException, and the other which catches
      # all java/lang/Throwable objects thrown from the target method
      # and wraps them in InvocationTargetExceptions.
      class_cast_handler = cb.get_length
      # ClassCast, etc. exception handler
      cb.set_stack(1)
      cb.opc_invokespecial(self.attr_to_string_idx, 0, 1)
      cb.opc_new(self.attr_illegal_argument_class)
      cb.opc_dup_x1
      cb.opc_swap
      cb.opc_invokespecial(self.attr_illegal_argument_string_ctor_idx, 1, 0)
      cb.opc_athrow
      invocation_target_handler = cb.get_length
      # InvocationTargetException exception handler
      cb.set_stack(1)
      cb.opc_new(self.attr_invocation_target_class)
      cb.opc_dup_x1
      cb.opc_swap
      cb.opc_invokespecial(self.attr_invocation_target_ctor_idx, 1, 0)
      cb.opc_athrow
      # Generate exception table. We cover the entire code sequence
      # with an exception handler which catches ClassCastException and
      # converts it into an IllegalArgumentException.
      exc = ClassFileAssembler.new
      exc.emit_short(illegal_arg_start_pc) # start PC
      exc.emit_short(invoke_start_pc) # end PC
      exc.emit_short(class_cast_handler) # handler PC
      exc.emit_short(self.attr_class_cast_class) # catch type
      exc.emit_short(illegal_arg_start_pc) # start PC
      exc.emit_short(invoke_start_pc) # end PC
      exc.emit_short(class_cast_handler) # handler PC
      exc.emit_short(self.attr_null_pointer_class) # catch type
      exc.emit_short(invoke_start_pc) # start PC
      exc.emit_short(invoke_end_pc) # end PC
      exc.emit_short(invocation_target_handler) # handler PC
      exc.emit_short(self.attr_throwable_class) # catch type
      emit_method(@invoke_idx, cb.get_max_locals, cb, exc, Array.typed(::Java::Short).new([self.attr_invocation_target_class]))
    end
    
    typesig { [] }
    def uses_primitive_types
      # We need to emit boxing/unboxing constant pool information if
      # the method takes a primitive type for any of its parameters or
      # returns a primitive value (except void)
      if (@return_type.is_primitive)
        return true
      end
      i = 0
      while i < @parameter_types.attr_length
        if (@parameter_types[i].is_primitive)
          return true
        end
        i += 1
      end
      return false
    end
    
    typesig { [] }
    def num_non_primitive_parameter_types
      num = 0
      i = 0
      while i < @parameter_types.attr_length
        if (!@parameter_types[i].is_primitive)
          (num += 1)
        end
        i += 1
      end
      return num
    end
    
    typesig { [] }
    def is_interface
      return @declaring_class.is_interface
    end
    
    typesig { [] }
    def build_internal_signature
      buf = StringBuffer.new
      buf.append("(")
      i = 0
      while i < @parameter_types.attr_length
        buf.append(get_class_name(@parameter_types[i], true))
        i += 1
      end
      buf.append(")")
      buf.append(get_class_name(@return_type, true))
      return buf.to_s
    end
    
    class_module.module_eval {
      typesig { [::Java::Boolean, ::Java::Boolean] }
      def generate_name(is_constructor, for_serialization)
        synchronized(self) do
          if (is_constructor)
            if (for_serialization)
              num = (self.attr_serialization_constructor_symnum += 1)
              return "sun/reflect/GeneratedSerializationConstructorAccessor" + RJava.cast_to_string(num)
            else
              num = (self.attr_constructor_symnum += 1)
              return "sun/reflect/GeneratedConstructorAccessor" + RJava.cast_to_string(num)
            end
          else
            num = (self.attr_method_symnum += 1)
            return "sun/reflect/GeneratedMethodAccessor" + RJava.cast_to_string(num)
          end
        end
      end
    }
    
    private
    alias_method :initialize__method_accessor_generator, :initialize
  end
  
end
